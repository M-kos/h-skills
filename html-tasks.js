//1. block и inline
//block - занимает всю ширину, можно задать высоту/марджины

//Junior
//2. разница flex и grid

//3. async, defer
// Атрибут defer сообщает браузеру, что он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме, а затем запустить этот скрипт, когда DOM дерево будет полностью построено.
// Скрипты с defer никогда не блокируют страницу.
// Скрипты с defer всегда выполняются, когда дерево DOM готово, но до события DOMContentLoaded.
// Отложенные с помощью defer скрипты сохраняют порядок относительно друг друга, как и обычные скрипты.

//Страница не ждёт асинхронных скриптов, содержимое обрабатывается и отображается.
//Событие DOMContentLoaded и асинхронные скрипты не ждут друг друга:
//DOMContentLoaded может произойти как до асинхронного скрипта (если асинхронный скрипт завершит загрузку после того, как страница будет готова),
//…так и после асинхронного скрипта (если он короткий или уже содержится в HTTP-кеше)
//Остальные скрипты не ждут async, и скрипты casync не ждут другие скрипты.


//4. специфичность
// Вес записывается в виде a, b, c, d, где:
// a — встроенные стили,
// b — селектор по идентификатору,
// c — селектор классов псевдоклассов и атрибутов,
// d — селектор по тегу и псевдоэлементу.

//5. изоляция css
// 1. Использование уникальных имен классов
// 2. CSS-модули
// 3. CSS-in-JS
// 4. Shadow DOM
// 5. Scoped CSS (Vue)

//6. Зачем указывать размер картинки

//Middle
//7. Ссылка или кнопка. Когда нужен див с кликом? (Например карточка товара, кнопку в кнопку вложить нельзя, по клику на карточку переходим в описание, по клику на кнопку добавляем в корзину)

//8. bubling и capturing

//9. html entities
// конструкция SGML, которая ссылается на символ из набора символов текстового файла
// https://www.toptal.com/designers/htmlarrows/symbols/
// Неразрывный пробел — специальный символ, который «связывает» два слова. Это позволяет избежать ситуации, когда одно слово остается на одной строке, а второе переносится на следующую

//10. shadow dom
// Теневой DOM – это способ создать свой, изолированный, DOM для компонента.
// shadowRoot = elem.attachShadow({mode: open|closed}) – создаёт теневой DOM для elem. Если mode="open", он доступен через свойство elem.shadowRoot.
// Мы можем создать подэлементы внутри shadowRoot с помощью innerHTML или других методов DOM.
// Элементы теневого DOM:
// Обладают собственной областью видимости идентификаторов
// Невидимы JavaScript селекторам из главного документа, таким как querySelector,
// Стилизуются своими стилями из теневого дерева, не из главного документа.
// Теневой DOM, если имеется, отрисовывается браузером вместо обычных потомков (light DOM)

//Senior
//11. почему в css нет селектора родителя
